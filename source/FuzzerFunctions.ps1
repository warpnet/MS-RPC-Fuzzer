#  Copyright 2025 Remco van der Meer. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

<#
.SYNOPSIS
Invoke the RPC Fuzzer
.DESCRIPTION
This cmdlet invokes the fuzzing process, will need the rpcServerData.json file as input, which was generated by Get-RpcServerData.
.PARAMETER DataFile
Specify the json file that was generated by Get-RpcServerData
.PARAMETER Mode
Specify the fuzzing mode
.INPUTS
JSON file
.OUTPUTS
JSON file
.EXAMPLE
'.\rpcServerData.json' | Invoke-RpcFuzzer -OutPath .\output\
Fuzzing with no options
.EXAMPLE
'.\rpcServerData.json' | Invoke-RpcFuzzer -OutPath .\output\ -Mode remote -remote_host 172.22.13.110
Remote mode with Remote host IPv4 specified
.EXAMPLE
'.\rpcServerData.json' | Invoke-RpcFuzzer -OutPath .\output\ -minStrLen 100 -maxStrLen 200
Specify length for Strings
.EXAMPLE
'.\rpcServerData.json' | Invoke-RpcFuzzer -OutPath .\output\ -minIntSize 10 -maxIntSize 20
Specify size for Integers
.EXAMPLE
'.\rpcServerData.json' | Invoke-RpcFuzzer -OutPath .\output\ -inputParameters $retval
Parse a complex parameter type (output from another RPC call)
#>
function Invoke-RpcFuzzer {
    param (
        [Parameter(ValueFromPipeline=$true)]
        [string]$DataFile,
        [ValidateSet("remote", "local")]
        [string]$Mode = "local",
        [string]$iterations = 1,
        [string]$remote_host,
        [string]$canary  = "incendiumrocks_",
        [string]$OutPath,
        [string]$StringInput,
        $inputParameters,
        $minStrLen = 5,
        $maxStrLen = 20,
        $minIntSize = 10,
        $maxIntSize = 100,
        $minByteArrLen = 100,
        $maxByteArrLen = 1000,
        $Procedure,
        $Blacklist,
        [ValidateSet("default", "sorted")]
        [string]$FuzzerType,
        [string]$DbgHelpPath
    )
    $rpcServerData = $DataFile

    # Call the fuzzer with the user specified options
    if ($FuzzerType -eq "sorted") {
        Invoke-SortedFuzzer -JsonFilePath $rpcServerData -Iterations $iterations -Canary $Canary -Mode $mode -remote_host $remote_host -OutPath $OutPath -StringInput $StringInput -minStrLen $minStrLen -maxStrLen $maxStrLen -minIntSize $minIntSize -maxIntSize $maxIntSize -minByteArrLen $minByteArrLen -maxByteArrLen $maxByteArrLen -inputParameters $inputParameters -Procedure $Procedure -Blacklist $Blacklist -DbgHelpPath $DbgHelpPath
    } else {
        Invoke-DefaultFuzzer -JsonFilePath $rpcServerData -Iterations $iterations -Canary $Canary -Mode $mode -remote_host $remote_host -OutPath $OutPath -StringInput $StringInput -minStrLen $minStrLen -maxStrLen $maxStrLen -minIntSize $minIntSize -maxIntSize $maxIntSize -minByteArrLen $minByteArrLen -maxByteArrLen $maxByteArrLen -inputParameters $inputParameters -Procedure $Procedure -Blacklist $Blacklist -DbgHelpPath $DbgHelpPath
    }
}

<#
.SYNOPSIS
Formats parameter types and calls input generator for values
.DESCRIPTION
This function formats the parameter type and calls the input generator for values
#>
Function Format-ParameterType {
    param (
        [Parameter(Mandatory=$true)]
        [System.Type]$Type,
        $Canary,
        $Mode,
        $remote_host,
        $inputParameters,
        $StringInput,
        $minStrLen = 5,
        $maxStrLen = 20,
        $minIntSize = 10,
        $maxIntSize = 100,
        $minByteArrLen = 100,
        $maxByteArrLen = 1000   
    )

    # Process each parameter
    process {
        # Is parameter type an Byte Array?
        if ($Type -eq [System.Byte[]]) {
            $value = CallInputGenerator -param $Type -canary $Canary -minByteArrLen $minByteArrLen -maxByteArrLen $maxByteArrLen
            return ,$value
        }
        # Is param type an Array?
        elseif ($Type.IsArray) {
            # [Recursive] Array
            return ,@(Format-ParameterType $Type.GetElementType())
        # Is param type an String?
        } elseif ($Type -eq [System.String]) {
            if ($StringInput) {
                $value = $StringInput
            } else {
                if ($Mode -eq "remote") {
                    $randomstring = CallInputGenerator -param $Type -canary $Canary -minStrLen $minStrLen -maxStrLen $maxStrLen
                    $value = ("\\" + $remote_host + "\test\" + $randomstring)
                } else {
                    $value = (CallInputGenerator -param $Type -canary $Canary -minStrLen $minStrLen -maxStrLen $maxStrLen)
                }
            }
            return $value
        # Is param type an Int32?
        } elseif ($Type -eq [System.Int32]) {
            $value = CallInputGenerator -param $Type -canary $Canary -minIntSize $minIntSize -maxIntSize $maxIntSize
            return [int32]$value
        # Is param type and Byte?
        } elseif ($Type -eq [System.Byte]) {
            # Default Byte value
            [System.Byte]0x41
        }
        # Did the user specify his own parameters?
        elseif ($inputParameters) {
            if ($inputParameters.(($retval | Get-Member -MemberType Property | Where-Object { $_.Name -match '^p\d+$' }).Name).GetType().FullName -contains $parameter.ParameterType.FullName) {
                return $inputParameters.p1 
            }
        # None of the above, dynamically create an instance for the parameter
        } else {
            return [System.Activator]::CreateInstance($Type)
        }
    }
}

<#
.SYNOPSIS
Process each parameter and format it
.DESCRIPTION
This function takes a Method as input and processes each parameter with a value
#>
Function Format-DefaultParameters {
    param (
        [Parameter(Mandatory=$true)]
        [System.Reflection.MethodInfo]$Method,
        $Canary,
        $Mode,
        $remote_host,
        $inputParameters,
        $StringInput,
        $minStrLen = 5,
        $maxStrLen = 20,
        $minIntSize = 10,
        $maxIntSize = 100,
        $minByteArrLen = 100,
        $maxByteArrLen = 1000  
    )
    # Process each parameter in a method (RPC procedure)
    process {
        $Method.GetParameters() | ForEach-Object {
            $parameter = $_
            $value = Format-ParameterType -Type $parameter.ParameterType -Mode $Mode -remote_host $remote_host -canary $Canary -StringInput $StringInput -minStrLen $minStrLen -maxStrLen $maxStrLen -minIntSize $minIntSize -maxIntSize $maxIntSize -minByteArrLen $minByteArrLen -maxByteArrLen $maxByteArrLen -inputParameters $inputParameters
            return ,$value
        }
    }
}


<#
.SYNOPSIS
Helper function to determine if a given Type is considered "complex" for fuzzing purposes.
.DESCRIPTION
A type is considered complex if it's not a common primitive or a byte array.
#>
function Test-IsComplexType {
    param (
        [Parameter(Mandatory=$true)]
        [System.Type]$Type
    )
    $primitiveTypes = @(
        [string], [int], [int32], [int64],
        [double], [float], [single],
        [bool], [byte], [char],
        [datetime], [guid], [void], [byte[]]
    )

    # If the type is in our list of primitive types, it's not complex.
    if ($primitiveTypes.Contains($Type)) {
        return $false
    }

    # If it's an enum, it's generally not considered a complex object for this purpose.
    if ($Type.IsEnum) {
        return $false
    }

    if ($Type.IsClass -or $Type.IsValueType) {
        return $true
    }

    return $false
}

<#
.SYNOPSIS
Formats parameter types and calls input generator for values
.DESCRIPTION
This function formats the parameter type and calls the input generator for values
#>
Function Format-SortedParameterType {
    param (
        [Parameter(Mandatory=$true)]
        [System.Type]$Type,
        $Canary,
        $Mode,
        $remote_host,
        $inputParameters,
        $StringInput,
        $minStrLen = 5,
        $maxStrLen = 20,
        $minIntSize = 10,
        $maxIntSize = 100,
        $minByteArrLen = 100,
        $maxByteArrLen = 1000,
        [Parameter(Mandatory=$true)]
        [hashtable]$InterfaceComplexParameters
    )

    # Process each parameter
    process {
        # Is parameter type an Byte Array?
        if ($Type -eq [System.Byte[]]) {
            $value = CallInputGenerator -param $Type -canary $Canary -minByteArrLen $minByteArrLen -maxByteArrLen $maxByteArrLen
            return ,$value
        }
        # Is param type an Array?
        elseif ($Type.IsArray) {
            # [Recursive] Array
            # When recursively calling, ensure InterfaceComplexParameters is passed down
            return ,@(Format-SortedParameterType -Type $Type.GetElementType() -Canary $Canary -Mode $Mode -remote_host $remote_host -inputParameters $inputParameters -StringInput $StringInput -minStrLen $minStrLen -maxStrLen $maxStrLen -minIntSize $minIntSize -maxIntSize $maxIntSize -minByteArrLen $minByteArrLen -maxByteArrLen $maxByteArrLen -InterfaceComplexParameters $InterfaceComplexParameters)
        # Is param type an String?
        } elseif ($Type -eq [System.String]) {
            if ($StringInput) {
                $value = $StringInput
            } else {
                if ($Mode -eq "remote") {
                    $randomstring = CallInputGenerator -param $Type -canary $Canary -minStrLen $minStrLen -maxStrLen $maxStrLen
                    $value = ("\\" + $remote_host + "\test\" + $randomstring)
                } else {
                    $value = (CallInputGenerator -param $Type -canary $Canary -minStrLen $minStrLen -maxStrLen $maxStrLen)
                }
            }
            return $value
        # Is param type an Int32?
        } elseif ($Type -eq [System.Int32]) {
            $value = CallInputGenerator -param $Type -canary $Canary -minIntSize $minIntSize -maxIntSize $maxIntSize
            return [int32]$value
        # Is param type and Byte?
        } elseif ($Type -eq [System.Byte]) {
            # Default Byte value
            [System.Byte]0x41
        }
        # Check if it's a complex type that might be stored
        elseif (Test-IsComplexType $Type) {
            $typeName = $Type.FullName

            $match = for ($i = 0; $i -lt $ComplexList["Type"].Count; $i++) {
                if ($ComplexList["Type"][$i] -imatch $typeName) {
                    [PSCustomObject]@{
                        Type  = $ComplexList["Type"][$i]
                        Value = $ComplexList["Value"][$i]
                    }
                }
            }
            if ($match) {
                return $($match.Value)
            } else {
                return [System.Activator]::CreateInstance($Type)
            }
        }
        # Did the user specify his own parameters? (Less priority now that we have InterfaceComplexParameters)
        elseif ($inputParameters) {
            Write-Verbose "  Format-SortedParameterType: Using '$inputParameters' which is not the primary mechanism for complex types now. Consider using InterfaceComplexParameters."
            return $inputParameters
            
        # None of the above, dynamically create an instance for the parameter
        } else {
            return [System.Activator]::CreateInstance($Type)
        }
    }
}

<#
.SYNOPSIS
Process each parameter and format it
.DESCRIPTION
This function takes a Method as input and processes each parameter with a value
#>
Function Format-SortedDefaultParameters {
    param (
        [Parameter(Mandatory=$true)]
        [System.Reflection.MethodInfo]$Method,
        $Canary,
        $Mode,
        $remote_host,
        $inputParameters,
        $StringInput,
        $minStrLen = 5,
        $maxStrLen = 20,
        $minIntSize = 10,
        $maxIntSize = 100,
        $minByteArrLen = 100,
        $maxByteArrLen = 1000,
        [Parameter(Mandatory=$true)]
        [hashtable]$InterfaceComplexParameters
    )
    # Process each parameter in a method (RPC procedure)
    $formattedParams = @()
    foreach ($parameter in $Method.GetParameters()) {
        $value = Format-SortedParameterType -Type $parameter.ParameterType -Mode $Mode -remote_host $remote_host -canary $Canary -StringInput $StringInput -minStrLen $minStrLen -maxStrLen $maxStrLen -minIntSize $minIntSize -maxIntSize $maxIntSize -minByteArrLen $minByteArrLen -maxByteArrLen $maxByteArrLen -inputParameters $inputParameters -InterfaceComplexParameters $InterfaceComplexParameters
        $formattedParams += [PSCustomObject]@{
            Name = $parameter.Name
            Type = $parameter.ParameterType.FullName
            IsComplex = (Test-IsComplexType $parameter.ParameterType)
            Value = ,$value
        }
    }
    return ,$formattedParams
}

<#
.SYNOPSIS
Takes a parameter and calls the input generator
.DESCRIPTION
This function calls the input generator for a parameter value
#>
function CallInputGenerator {
    Param (
        $param,
        $canary,
        $minStrLen,
        $maxStrLen,
        $minIntSize,
        $maxIntSize,
        $minByteArrLen,
        $maxByteArrLen        
    ) 
    # $iterations is a global variable from Invoke-Fuzzer scope, so it should be accessible here
    $value = GenerateInput -paramType $param -count $iterations -canary $Canary -minStrLen $minStrLen -maxStrLen $maxStrLen -minIntSize $minIntSize -maxIntSize $maxIntSize -minByteArrLen $minByteArrLen -maxByteArrLen $maxByteArrLen               
    return $value
}

<#
.SYNOPSIS
Connect a client using a stringbinding
.DESCRIPTION
This function connects a client using a stringbinding
#>
function ConnectRpcClient {
    param (
        $client,
        $stringbinding
    )    
    # Connect to the RPC server using the provided stringbinding
    try {
        if ($stringbinding -match "ncacn_np") {
            try {
                Connect-RpcClient $client -stringBinding $stringbinding -AuthenticationLevel PacketPrivacy -AuthenticationType WinNT
            } catch {
                if ($_ -match "AuthenticationTypeNotRecognized") {
                    Connect-RpcClient $client -stringBinding $stringbinding
                }
            }
        } else {
            Connect-RpcClient $client -stringBinding $stringbinding
        }
    } catch {
        Write-Verbose "[!] Error connecting client : $_"
    }
}
