#  Copyright 2025 Remco van der Meer. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

<#
.SYNOPSIS
Creates nodes for RPC servers in Neo4j
.DESCRIPTION
This function exports Allowed fuzzed input to a json file
#>
function Add-RpcServerNode {
    param ([PSCustomObject]$RpcServer)
    $cypher = @"
        MERGE (rpcServer:RpcServer {
            Name: `"$($RpcServer.Name)`",
            UUID: `"$($RpcServer.InterfaceId)`",
            AvailableEndpoints: `"$($RpcServer.Endpoints.BindingString)`"
        })
"@
    Invoke-CustomNeo4jQuery -Query $cypher | Out-Null
}

<#
.SYNOPSIS
Creates a ACL node for Endpoint in Neo4j
.DESCRIPTION
This function creates a ACL node for Endpoint in Neo4j
#>
function Add-RpcACLEndpointNode {
    param (
        [string]$Endpoint,
        [PSCustomObject]$ACL
    )

    # Check if ACL is present before proceeding
    if ($ACL -and $ACL.Access) {
        $Owner = $ACL.Owner
        $Group = $ACL.Group

        # Build the Access entries as a string
        $AccessEntries = ($ACL.Access | ForEach-Object {
            "`r`n$($_.IdentityReference) -> $($_.AccessControlType) -> $($_.FileSystemRights)"
        }) -join ', '        

        $cypher = @"
            MERGE (endpoint:Endpoint { Name: `"$Endpoint`" })
            CREATE (acl:ACL {
                Owner: `"$Owner`",
                Group: `"$Group`",
                AccessEntries: `"$AccessEntries`"
            })
            MERGE (endpoint)-[:HAS_ACL]->(acl)
"@
        Invoke-CustomNeo4jQuery -Query $cypher | Out-Null
    }
}

<#
.SYNOPSIS
Creates a ACL node for a server in Neo4j
.DESCRIPTION
This function creates a ACL node for a server in Neo4j
#>
function Add-RpcACLServerNode {
    param (
        [string]$RpcServerName,
        [PSCustomObject]$ACL
    )

    # Check if ACL is present before proceeding
    if ($ACL -and $ACL.Access) {
        $Owner = $ACL.Owner
        $Group = $ACL.Group

        # Build the Access entries as a string
        $AccessEntries = ($ACL.Access | ForEach-Object {
            "`r`n$($_.IdentityReference) -> $($_.AccessControlType) -> $($_.FileSystemRights)"
        }) -join ', '

        # Cypher query to create a single ACL node with all the info
        $cypher = @"
            MERGE (rpcServer:RpcServer { Name: `"$RpcServerName`" })
            CREATE (acl:ACL {
                Owner: `"$Owner`",
                Group: `"$Group`",
                AccessEntries: `"$AccessEntries`"
            })
            MERGE (rpcServer)-[:HAS_ACL]->(acl)
"@
        Invoke-CustomNeo4jQuery -Query $cypher | Out-Null
    }
}

<#
.SYNOPSIS
Creates relationships for methods in Neo4j
.DESCRIPTION
This function creates relationships for methods in Neo4j
#>
function Add-MethodNode {
    param (
        [string]$MethodName,
        [string]$RpcServerName,
        [string]$ProcedureName,
        [string]$MethodDefinition
    )
    $cypher = @"
        MERGE (rpcServer:RpcServer { Name: `"$RpcServerName`" })
        MERGE (rpcServer)-[:HAS_ENDPOINT]->(endpoint)
        MERGE (method:Method { Name: `"$MethodName`", Definition: `"$MethodDefinition`" })
        MERGE (endpoint)-[:WITH_METHOD]->(method)
"@
    Invoke-CustomNeo4jQuery -Query $cypher | Out-Null
}

<#
.SYNOPSIS
Decides relationship type for Fuzzed inputs in Neo4j
.DESCRIPTION
This function decides relationship type for Fuzzed inputs in Neo4j
#>
function Add-FuzzedInputNodeFromJson {
    param (
        [string]$JsonFilePath
    )
    if ($JsonFilePath -match "Allowed") {
        Add-AllowsFuzzedInputNodeFromJson($JsonFilePath)
    } elseif ($JsonFilePath -match "Denied") {
        Add-AccessDeniedFuzzedInputNodeFromJson($JsonFilePath)
    } elseif ($JsonFilePath -match "Error") {
        Add-ErrorFuzzedInputNodeFromJson($JsonFilePath)
    } elseif ($JsonFilePath -match "Parameters") {
        Add-ParameterInputNodeFromJson($JsonFilePath)        
    } else {
        Write-Host "Error importing data to Neo4j, check your path $_"
    }
}

<#
.SYNOPSIS
Gets the necessary parameters from the allowed fuzz input JSON file
.DESCRIPTION
This function gets the necessary parameters from the allowed fuzz input JSON file
.PARAMETER JsonFilePath
Specify the allowed json file that was generated by Invoke-RPCFuzzer
.INPUTS
JSON file
.OUTPUTS
None
#>
function Add-AllowsFuzzedInputNodeFromJson {
    param (
        [string]$JsonFilePath
    )

    # Import JSON data from the file
    $jsonData = Get-Content -Path $JsonFilePath | ConvertFrom-Json
    # Loop through each key in the JSON (rpc-server.exe, etc.)
    foreach ($dllName in $jsonData.PSObject.Properties.Name) {
        # Loop through each method ID
        foreach ($methodId in $jsonData.$dllName.PSObject.Properties.Name) {
            # Loop through the array of method data for each method ID
            foreach ($method in $jsonData.$dllName.$methodId) {
                # Call the original Add-AllowsFuzzedInputNode function with the appropriate parameters,
                Add-AllowsFuzzedInputNode -MethodName $method.MethodName `
                                          -RpcServerName $dllName `
                                          -RpcInterface $methodId `
                                          -Endpoint $method.Endpoint `
                                          -ProcedureName $method.ProcedureName `
                                          -MethodDefinition $method.MethodDefinition `
                                          -Service $method.Service `
                                          -FuzzInput $method.FuzzInput `
                                          -Output $method.Output `
                                          -WindowsMessage $method.WindowsMessage
            }
        }
    }
}

<#
.SYNOPSIS
Creates relationships for Allowed Fuzzed inputs in Neo4j
.DESCRIPTION
This cmdlet creates relationships for Allowed Fuzzed inputs in Neo4j
#>
function Add-AllowsFuzzedInputNode {
    param (
        [string]$MethodName, 
        [string]$RpcServerName,
        [string]$RpcInterface,
        [string]$Endpoint, 
        [string]$ProcedureName, 
        [string]$MethodDefinition,
        [string]$Service,
        [string]$FuzzInput, 
        [string]$Output,
        [string]$windowsMessage
    )
    $cypher = @"
        MERGE (rpcServer:RpcServer { Name: `"$RpcServerName`" })
        MERGE (rpcInterface:RpcInterface { UUID: `"$RpcInterface`" })
        MERGE (endpoint:Endpoint { Name: `"$Endpoint`" })
        MERGE (rpcServer)-[:HAS_INTERFACE]->(rpcInterface)
        MERGE (rpcInterface)-[:HAS_ENDPOINT]->(endpoint)
        MERGE (method:Method { Name: `"$MethodName`", Definition: `"$MethodDefinition`" })
        MERGE (rpcInterface)-[:WITH_METHOD]->(method)
        CREATE (allowsinput:AllowsInput { 
            Name: `"$MethodName`", 
            Definition: `"$MethodDefinition`", 
            FuzzInput: `"$FuzzInput`", 
            FuzzOutput: `"$Output`",
            Endpoint: `"$Endpoint`",
            WindowsMessage: `"$windowsMessage`"
        })
        MERGE (method)-[:ALLOWS_INPUT]->(allowsinput)

        FOREACH (_ IN CASE WHEN `"$Service`" <> 'N.a.' THEN [1] ELSE [] END |
            MERGE (service:Service { Name: `"$Service`" })
            MERGE (rpcServer)-[:SERVICE]->(service)
        )        
"@
    Invoke-CustomNeo4jQuery -Query $cypher | Out-Null
}

<#
.SYNOPSIS
Gets the necessary parameters from the access denied fuzz input JSON file
.DESCRIPTION
This function gets the necessary parameters from the access denied fuzz input JSON file
.PARAMETER JsonFilePath
Specify the access denied json file that was generated by Invoke-RPCFuzzer
.INPUTS
JSON file
.OUTPUTS
None
#>
function Add-AccessDeniedFuzzedInputNodeFromJson {
    param (
        [string]$JsonFilePath
    )

    # Import JSON data from the file
    $jsonData = Get-Content -Path $JsonFilePath | ConvertFrom-Json

    # Loop through each key in the JSON (each DLL in your case)
    foreach ($dllName in $jsonData.PSObject.Properties.Name) {
        # Loop through each method ID (UUID or unique key in your JSON)
        foreach ($methodId in $jsonData.$dllName.PSObject.Properties.Name) {
            # Loop through the array of method data for each method ID
            foreach ($method in $jsonData.$dllName.$methodId) {
                # Call the original Add-AccessDeniedFuzzedInputNode function with the appropriate parameters
                Add-AccessDeniedFuzzedInputNode -MethodName $method.MethodName `
                                                -RpcServerName $dllName `
                                                -RpcInterface $methodId `
                                                -Endpoint $method.Endpoint `
                                                -ProcedureName $method.ProcedureName `
                                                -MethodDefinition $method.MethodDefinition `
                                                -Service $method.Service `
                                                -FuzzInput $method.FuzzInput
            }
        }
    }
}

<#
.SYNOPSIS
Creates relationships for Access Denied Fuzzed inputs in Neo4j
.DESCRIPTION
This cmdlet creates relationships for Access Denied Fuzzed inputs in Neo4j
#>
function Add-AccessDeniedFuzzedInputNode {
    param (
        [string]$MethodName, 
        [string]$RpcServerName,
        [string]$RpcInterface,
        [string]$Endpoint, 
        [string]$ProcedureName, 
        [string]$MethodDefinition, 
        [string]$Service,
        [string]$FuzzInput
    )
    $cypher = @"
        MERGE (rpcServer:RpcServer { Name: `"$RpcServerName`" })
        MERGE (rpcInterface:RpcInterface { UUID: `"$RpcInterface`" })
        MERGE (endpoint:Endpoint { Name: `"$Endpoint`" })
        MERGE (rpcServer)-[:HAS_INTERFACE]->(rpcInterface)
        MERGE (rpcInterface)-[:HAS_ENDPOINT]->(endpoint)
        MERGE (method:Method { Name: `"$MethodName`", Definition: `"$MethodDefinition`" })
        MERGE (rpcInterface)-[:WITH_METHOD]->(method)
        MERGE (accessdenied:AccessDenied { 
            Name: `"$MethodName`", 
            Definition: `"$MethodDefinition`", 
            FuzzInput: `"$FuzzInput`",
            Endpoint: `"$Endpoint`"
        })
        MERGE (method)-[:ACCESS_DENIED]->(accessdenied)

        FOREACH (_ IN CASE WHEN `"$Service`" <> 'N.a.' THEN [1] ELSE [] END |
            MERGE (service:Service { Name: `"$Service`" })
            MERGE (rpcServer)-[:SERVICE]->(service)
        )
"@
    Invoke-CustomNeo4jQuery -Query $cypher | Out-Null
}


<#
.SYNOPSIS
Gets the necessary parameters from the error fuzz input JSON file
.DESCRIPTION
This function gets the necessary parameters from the error fuzz input JSON file
.PARAMETER JsonFilePath
Specify the error json file that was generated by Invoke-RPCFuzzer
.INPUTS
JSON file
.OUTPUTS
None
#>
function Add-ErrorFuzzedInputNodeFromJson {
    param (
        [string]$JsonFilePath
    )

    # Import JSON data from the file
    $jsonData = Get-Content -Path $JsonFilePath | ConvertFrom-Json

    # Loop through each key in the JSON (each DLL in your case)
    foreach ($dllName in $jsonData.PSObject.Properties.Name) {
        # Loop through each method ID (UUID or unique key in your JSON)
        foreach ($methodId in $jsonData.$dllName.PSObject.Properties.Name) {
            # Loop through the array of method data for each method ID
            foreach ($method in $jsonData.$dllName.$methodId) {
                # Call the original Add-ErrorFuzzedInputNode function with the appropriate parameters
                Add-ErrorFuzzedInputNode -MethodName $method.MethodName `
                                         -RpcServerName $dllName `
                                         -RpcInterface $methodId `
                                         -Endpoint $method.Endpoint `
                                         -ProcedureName $method.ProcedureName `
                                         -MethodDefinition $method.MethodDefinition `
                                         -Service $method.Service `
                                         -FuzzInput $method.FuzzInput `
                                         -Errormessage $method.ErrorMessage
            }
        }
    }
}

<#
.SYNOPSIS
Creates relationships for error Fuzzed inputs in Neo4j
.DESCRIPTION
This cmdlet creates relationships for error Fuzzed inputs in Neo4j
#>
function Add-ErrorFuzzedInputNode {
    param (
        [string]$MethodName, 
        [string]$RpcServerName, 
        [string]$RpcInterface,
        [string]$Endpoint, 
        [string]$ProcedureName, 
        [string]$MethodDefinition, 
        [string]$FuzzInput,
        [string]$Service,
        [string]$Errormessage
    )
    $cypher = @"
    MERGE (rpcServer:RpcServer { Name: `"$RpcServerName`" })
    MERGE (rpcInterface:RpcInterface { UUID: `"$RpcInterface`" })
    MERGE (endpoint:Endpoint { Name: `"$Endpoint`" })
    MERGE (rpcServer)-[:HAS_INTERFACE]->(rpcInterface)
    MERGE (rpcInterface)-[:HAS_ENDPOINT]->(endpoint)
    MERGE (method:Method { Name: `"$MethodName`", Definition: `"$MethodDefinition`" })
    MERGE (rpcInterface)-[:WITH_METHOD]->(method)
    CREATE (error:Error { 
        Name: `"$MethodName`", 
        Definition: `"$MethodDefinition`", 
        FuzzInput: `"$FuzzInput`",
        Endpoint: `"$Endpoint`",
        Error: `"$Errormessage`"
    })
    MERGE (method)-[:ERROR]->(error)

    FOREACH (_ IN CASE WHEN `"$Service`" <> 'N.a.' THEN [1] ELSE [] END |
        MERGE (service:Service { Name: `"$Service`" })
        MERGE (rpcServer)-[:SERVICE]->(service)

        FOREACH (_2 IN CASE WHEN `"$Errormessage`" CONTAINS 'The ALPC message requested is no longer available' THEN [1] ELSE [] END |
            MERGE (error)-[:CAUSES_CRASH]->(service)
        )
    )
"@
    Invoke-CustomNeo4jQuery -Query $cypher | Out-Null
}

# Function to create relationships for fuzzed input nodes that resulted in a function call in neo4j
<#
.SYNOPSIS
Creates relationships for fuzzed input nodes that resulted in a function call in neo4j
.DESCRIPTION
This function creates relationships for fuzzed input nodes that resulted in a function call in neo4j
.PARAMETER PMLEvent
One Process Monitor Event in CSV format
.PARAMETER Canary
The canary that was used when fuzzing
.OUTPUTS
None
#>
function Add-FunctionCallToAllowedInput {
    param (
        [PSObject]$PMLEvent,
        [string]$Canary
    )
    
    # Extract the relevant details from the $Event object
    $ProcessName = $PMLEvent.'Process Name'
    $Path = $PMLEvent.Path
    $Path = $Path -replace "\\", "\\"
    try {
        $fuzzinput = ($PMLEvent.Path -creplace "^.*\\$Canary", "$Canary")
    } catch {
        if ($_ -imatch "regular expression") {
            Write-Verbose "[!] Regex error with Canary, but we can continue"
        } else {
            Write-Verbose "[!] Error with Canary: $_"
        }
    }
    $fuzzinput = $fuzzinput -replace "\\", "\\"
    $Operation = $PMLEvent.Operation
    $eventPID = $PMLEvent.PID
    $user = $PMLEvent.User
    $detail = $PMLEvent.Detail
    $impersonating = "No impersonation"
    $AccessOptions = "Not Available"

    if ($detail -match "Impersonating:\s+([\S]+)") {
        $impersonating = $matches[1] -replace "\\", "\\"
    }

    # Extract Desired Access options if present
    if ($detail -match "Desired Access:\s*(.*?)(?=\s+\w+:)") {
        $AccessOptions = $matches[1].Trim()
    }

    # If no manual string input was parsed, we probably want to remove the '.'
    # This do prevent Process Monitor and Fuzzing input not being able to compare (because for some function calls, services add a extension)
    if (-not $StringInput) {
        $fuzzinput = ($fuzzinput -split '\.')[0]
    }

    # Also check for high privileged file operations without impersonation
    if ($Operation -match "file" -and $user -match "NT AUTHORITY" -and $impersonating -eq "No impersonation") {
        $cypher = @"
            MATCH (allowsinput:AllowsInput)
            WHERE allowsinput.FuzzInput CONTAINS `"$fuzzinput`"
            CREATE (highPrivilegedFileOp:HighPrivilegedFileOp {
                Path: `"$Path"`,
                Operation: `"$Operation"`,
                Process: `"$ProcessName"`,
                PID: `"$eventPID"`,
                User: `"$user"`,
                Impersonating: `"$impersonating"`,
                AccessOptions: `"$AccessOptions"`
            })
            MERGE (allowsinput)-[:HIGH_PRIVILEGED_FILE_OP]->(highPrivilegedFileOp)
"@  
    } else {
        # Find the existing 'AllowedInput' node by the method name and path
        $cypher = @"
            MATCH (allowsinput:AllowsInput)
            WHERE allowsinput.FuzzInput CONTAINS `"$fuzzinput`"
            CREATE (functionCall:FunctionCall {
                Path: `"$Path"`,
                Operation: `"$Operation"`,
                Process: `"$ProcessName"`,
                PID: `"$eventPID"`,
                User: `"$user"`,
                Impersonating: `"$impersonating"`,
                AccessOptions: `"$AccessOptions"`
            })
            MERGE (allowsinput)-[:CALLS_FUNCTION]->(functionCall)
"@
    }
    Invoke-CustomNeo4jQuery -Query $cypher | Out-Null   
}

<#
.SYNOPSIS
Gets the parameters from the parameters.json file in the right format
.DESCRIPTION
This function gets the necessary keys from the parameters.json file
.PARAMETER JsonFilePath
Specify the parameters.json file that was generated with Get-RpcParameters
.INPUTS
JSON file
.OUTPUTS
None
#>
function Add-ParameterInputNodeFromJson {
    param (
        [string]$JsonFilePath
    )

    # Import JSON data from the file
    $jsonData = Get-Content -Path $JsonFilePath | ConvertFrom-Json -AsHashtable

    # Loop through each RPC Server
    foreach ($rpcServerName in $jsonData.Keys) {
        $rpcServerData = $jsonData[$rpcServerName]

        # Loop through each RPC Interface
        foreach ($rpcInterfaceName in $rpcServerData.Keys) {
            $methods = $rpcServerData[$rpcInterfaceName]

            # Loop through method parameter entries
            foreach ($method in $methods) {
                Import-ParametersToNeo4j -RpcServerName $rpcServerName `
                                         -RpcInterface $rpcInterfaceName `
                                         -MethodName $method.MethodName `
                                         -Position $method.Position `
                                         -ParameterType $method.ParameterType `
                                         -Is $method.Is
            }
        }
    }
}

<#
.SYNOPSIS
Creates relationships for parameters in Neo4j
.DESCRIPTION
This cmdlet creates relationships for parameters in Neo4j
#>
function Import-ParametersToNeo4j {
    param (
        [string]$RpcServerName,
        [string]$RpcInterface,
        [string]$MethodName,
        [string]$Position,
        [string]$ParameterType,
        [string]$Is
    )

    $cypher = @"
        MERGE (rpcServer:RpcServer { Name: `"$RpcServerName`" })
        MERGE (method:Method { Name: `"$MethodName`" })
        MERGE (rpcInterface)-[:EXPOSES_METHOD]->(method)
        MERGE (parameter:Parameter { Name: `"$Position`", Type: `"$ParameterType`", Direction: `"$Is`" })
        MERGE (method)-[:HAS_PARAMETER]->(parameter)
"@

    Invoke-CustomNeo4jQuery -Query $cypher | Out-Null
}