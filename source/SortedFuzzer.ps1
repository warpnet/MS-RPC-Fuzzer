#  Copyright 2025 Remco van der Meer. All Rights Reserved.
#
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
#
#  http://www.apache.org/licenses/LICENSE-2.0
#
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.

<#
.SYNOPSIS
Invoke the RPC Fuzzer
.DESCRIPTION
This function starts the fuzzing process, get's invokes by Invoke-RpcFuzzer
.PARAMETER DataFile
Specify the json file that was generated by Get-RpcServerData
.PARAMETER Mode
Specify the fuzzing mode
.INPUTS
JSON file
.OUTPUTS
JSON file
#>
function Invoke-SortedFuzzer {
    param ($JsonFilePath,
            $Iterations,
            $Canary,
            $Mode,
            $remote_host,
            [Parameter(Mandatory=$true)]
            $OutPath,
            $StringInput,
            $intInput,
            $guidInput,            
            $inputParameters,
            $minStrLen,
            $maxStrLen,
            $minIntSize,
            $maxIntSize,
            $minByteArrLen,
            $maxByteArrLen,
            $Procedure,
            $Blacklist,
            $DbgHelpPath
    )
    # Read and parse the JSON file
    $ClientEntries = Get-Content -Path $JsonFilePath | ConvertFrom-Json

    # Initialize DbgHelp DLL
    if (Test-Path "$env:systemdrive\Program Files (x86)\Windows Kits\10\Debuggers\x64\dbghelp.dll") {
        Set-GlobalSymbolResolver -DbgHelpPath "$env:systemdrive\Program Files (x86)\Windows Kits\10\Debuggers\x64\dbghelp.dll"   
        Write-Host "[+] dbghelp.dll successfully initialized" -ForegroundColor Green
    } else {
        if ($DbgHelpPath) {
            try {
                Set-GlobalSymbolResolver -DbgHelpPath $DbgHelpPath    
                Write-Host "[+] dbghelp.dll successfully initialized" -ForegroundColor Green
            } catch {
                Write-host "[!] dbghelp.dll not found, please provide path using -DbgHelpPath" -ForegroundColor Red
                break
            }
        } else {
            $continueWithoutDbgPath = Read-Host "[!] Could not find dbghelp.dll, continue? [Y/n] > "
            if ($continueWithoutDbgPath -eq 'n') {
                break
            }
        }
    }   

    # Check if $outPath exists, if not make the directory
    if (-Not (Test-Path $OutPath)) {
        # Creating Path
        New-Item -ItemType Directory -Path $OutPath
    }

    Write-Host "[+] Starting fuzzer..." -ForegroundColor Green
    
    # Check if a blacklsit is parsed
    if ($Blacklist) {
        $Blacklist = Get-Content $Blacklist
    }

    # First, get all entries from the specified RpcServerData JSON file
    foreach ($rpcServer in $ClientEntries.PSObject.Properties) {  
        $serverName = $rpcServer.Name
        $interfaces = $rpcServer.Value 

        # Get the RPC server object
        try {
            $rpcServerObj = $serverName | Get-RpcServer -ErrorAction stop
        } catch {
            if ($_ -match "ParsePeFile") {
                $rpcServerObj = $serverName | Get-RpcServer -IgnoreSymbols
            } else {
                Write-Verbose "[!] Could not get RPC interface for $ServerName"
            }
        }

        if (-not $rpcServerObj) {
            Write-Host "[!] Failed to retrieve RPC server for: $serverName" -ForegroundColor Red
            continue
        } 

        # Now we loop over all interfaces of the RPC server
        foreach ($interfaceEntry in $interfaces) {
            $interfaceId = $interfaceEntry.InterfaceId
            $stringBindings = $interfaceEntry.StringBindings

            # Find the matching interface in the retrieved RPC server object
            $rpcInterface = $rpcServerObj | Where-Object { $_.InterfaceId -eq $interfaceId }

            if (-not $rpcInterface) {
                Write-Host "[!] Interface $interfaceId not found in RPC server $serverName" -ForegroundColor Yellow
                continue
            }

            # Try to get the service from the RPC interface
            $service = $rpcInterface.ServiceName
                
            # If NtObjectManager cannot find a service for the interface, make it "N.a."
            if ($service -eq "") {
                $service = "N.a."
            }

            # Get the RPC client
            try {
                $client = $rpcInterface | Get-RpcClient
            }
            catch {
                Write-Verbose "[!] Could not get RPC client for $rpcInterface"
            }

            if (-not $client) {
                Write-Verbose "[!] Failed to create RPC client for interface $interfaceId on server $serverName"
                continue
            }

            # Initialize stored parameters list for the current interface
            # This will hold actual instances of complex objects produced by methods in this interface.
            $ComplexList = @{
                Type = @()
                Value = @()
            }

            # Loop over all stringbindings for the RPC interface
            foreach ($stringbinding in $stringBindings) {
                # Connect the RPC client
                Connect-Client -client $client -stringbinding $stringbinding
                
                # Get methods for the RPC interface
                if ($Procedure) {
                    # User only wants to fuzz one specific procedure
                    $RpcIntMethods = $Client.GetType().GetMethods() | Where-Object { $_.IsPublic -and $_.DeclaringType -eq $Client.GetType() -and $_.Name -eq $Procedure}
                } else {
                    $RpcIntMethods = $Client.GetType().GetMethods() | Where-Object { $_.IsPublic -and $_.DeclaringType -eq $Client.GetType() }
                }

                $jsonData = Get-Content -Path $JsonFilePath | ConvertFrom-Json

                # Sort the procedures based on their dependencies
                $methods = SortProcedures -methods $RpcIntMethods

                # Keep track of process methods for showing progress
                $processedMethods = 0
                $totalMethods += $methods.Count

                # Loop over each method for the RPC interface (now in sorted order)
                foreach ($Method in $methods) {

                    $processedMethods++
                    # Display progress bar
                    $percentComplete = [math]::Round(($processedMethods / $totalMethods) * 100, 2)
                    Write-Progress -Activity "Fuzzing RPC Methods" -Status "Processing: $($method.Name)" -PercentComplete $percentComplete
                        
                    # Fuzz
                    try {
                        # Loop trough number of iterations (for the input of parameters)
                        for ($i = 0; $i -lt $Iterations; $i++) {

                            # Loop through each parameter in the method's parameter types
                            # Pass the InterfaceComplexParameters to Format-SortedDefaultParameters
                            $params = Format-SortedDefaultParameters -Method $Method -Mode $Mode -remote_host $remote_host -canary $Canary -inputParameters $inputParameters -StringInput $StringInput -IntInput $intInput -GuidInput $GuidInput -minStrLen $minStrLen -maxStrLen $maxStrLen -minIntSize $minIntSize -maxIntSize $maxIntSize -minByteArrLen $minByteArrLen -maxByteArrLen $maxByteArrLen -InterfaceComplexParameters $ComplexList

                            try {
                                $RpcInterface = $Client.InterfaceId.Uuid
                                $matchingEntry = $jsonData.PSObject.Properties | Where-Object {
                                    $_.Value.InterfaceId -eq $RpcInterface
                                }
                                $filePath = $matchingEntry.Name
                                $rpcServerName = Split-Path -Path $filePath -Leaf
                                $procedureName = $Method.Name
                                $methodName = $procedureName
                                $Endpoint =  $Client.Endpoint.ToString()
                                $Endpoint = $Endpoint.replace("\u", "*u")
                                $methodDefinition = $Method.ToString()

                                # Prepare parameters for logging
                                $inputResult = if ($params.Count -gt 0) {
                                    # Convert parameters to a string for logging, handling complex types
                                    ($params | ForEach-Object {
                                        if ($_.IsComplex) {
                                            "$($_.Name)=$($_.Type) (Complex)"
                                        } else {
                                            "$($_.Name)=$($_.Value -replace '"', '')"
                                        }
                                    } | Out-String).Trim()
                                }  else { "No input" }
                                $inputResult = $inputResult.replace('"', '')
                                
                                # Invoke RPC call
                                # Extract only the values from the $params array for the Method.Invoke call
                                $invokeParams = $params | ForEach-Object { $_.Value }

                                # Check if procedure in blacklist, if so do not execute
                                if ($Blacklist -notcontains $ProcedureName -and $ProcedureName -notmatch "close" -and $ProcedureName -notmatch "delete") {
                                    # Log before making the RPC call
                                    $logEntry = "RPCserver: $rpcServerName `nInterface: $RpcInterface `nProcedure: $procedureName`nParams: $inputResult`n------------------------`n"
                                    $logFilePath = "$OutPath\log.txt"
                                    $logEntry | Out-File -FilePath $logFilePath -Append -Encoding utf8

                                    # If a sleep value is specified, wait for that amount of seconds before making the next call
                                    if ($sleep) {
                                        Sleep($sleep)
                                    }

                                    # Make the call
                                    $result = $Method.Invoke($Client, $invokeParams)
                                } else {
                                    Continue
                                }

                                $result.PSObject.Properties | ForEach-Object {
                                    if ($_.Value -notmatch '00000000-0000-0000-0000-000000000000') {
                                        $ComplexList["Type"] += $_.TypeNameOfValue.ToString()
                                        $ComplexList["Value"] += $_.Value
                                    }
                                }

                                # Check first if output has properties, if so we want all the properties in the output of Neo4j
                                if ($result.PSObject.Properties.MemberType) {
                                    $allOutputResult = $result | Get-Member -MemberType Properties | ForEach-Object {
                                        $value = ($result.$($_.Name)) -replace '"', ''
                                        if ($value -ne '') {
                                            "$($_.Name): $($value)"
                                        } else {
                                            "$($_.Name): N/A"
                                        }
                                    }
                                } else {
                                    $allOutputResult = $result -replace '"', ''
                                }
        
                                # Loop over each output result
                                foreach ($value in $allOutputResult) {
                                    if ($value -match 'retval') {
                                        $value = $value.replace('retval: ', '')
                                    } 
                                    try {
                                        # Check if the result is a Windows message
                                        $windowsMessage = [System.ComponentModel.Win32Exception]::new([Int]($value)).Message
                                        if ($windowsMessage -ne $value) {
                                            # Output is a windows message
                                            $windowsMessage = "$("{0:X}" -f ($value -band 0xFFFFFFFF)): $windowsMessage"
                                        } else {
                                            $windowsMessage = "No Windows Message"
                                        }
                                    } catch {
                                        $windowsMessage = "No Windows Message"
                                    }
                                }
        
                                $outputResult = $allOutputResult
        
                                # Add Fuzzed results to Neo4j
                                Export-AllowsFuzzedInput -MethodName $methodName `
                                                        -RpcServerName $rpcServerName `
                                                        -RpcInterface $RpcInterface `
                                                        -Endpoint $Endpoint `
                                                        -ProcedureName $procedureName `
                                                        -MethodDefinition $methodDefinition `
                                                        -Service $service `
                                                        -FuzzInput $inputResult `
                                                        -Output $outputResult `
                                                        -windowsMessage $windowsMessage `
                                                        -OutPath $OutPath `
                            } catch {
                                # Handle Access Denied (0x80070005)
                                if ($_ -match "Access is denied") {
                                    $Endpoint =  $Client.Endpoint.ToString()
                                    $Endpoint = $Endpoint.replace("\u", "*u")
                                    # Add access denied results to Neo4j
                                    Export-AccessDeniedInput -MethodName $methodName `
                                                                    -RpcServerName $rpcServerName `
                                                                    -RpcInterface $Client.InterfaceId.Uuid `
                                                                    -Endpoint $Endpoint `
                                                                    -ProcedureName $procedureName `
                                                                    -MethodDefinition $methodDefinition `
                                                                    -Service $service `
                                                                    -FuzzInput $inputResult `
                                                                    -OutPath $OutPath `
                                } elseif ($_ -match "not connected") {
                                    # Try to reconnect the RPC client
                                    Connect-Client -client $client -stringbinding $stringbinding

                                    # Also write error message to results
                                    $Errormessage = $_ -replace '"', ''
                                    $Endpoint =  $Client.Endpoint.ToString()
                                    $Endpoint = $Endpoint.replace("\u", "*u")
                                    Export-ErrorFuzzedInput -MethodName $methodName `
                                                            -RpcServerName $rpcServerName `
                                                            -RpcInterface $Client.InterfaceId.Uuid `
                                                            -Endpoint $Endpoint `
                                                            -ProcedureName $procedureName `
                                                            -MethodDefinition $methodDefinition `
                                                            -Service $service `
                                                            -FuzzInput $inputResult `
                                                            -Errormessage $Errormessage `
                                                            -OutPath $OutPath `                                    
                                } elseif ($_ -match "pipe is in the disconnected state") {
                                    # Disconnect client and reconnect
                                    Disconnect-RpcClient $client
                                    Connect-Client -client $client -stringbinding $stringbinding

                                    # Also write error message to results
                                    $Errormessage = $_ -replace '"', ''
                                    $Endpoint =  $Client.Endpoint.ToString()
                                    $Endpoint = $Endpoint.replace("\u", "*u")
                                    Export-ErrorFuzzedInput -MethodName $methodName `
                                                            -RpcServerName $rpcServerName `
                                                            -RpcInterface $Client.InterfaceId.Uuid `
                                                            -Endpoint $Endpoint `
                                                            -ProcedureName $procedureName `
                                                            -MethodDefinition $methodDefinition `
                                                            -Service $service `
                                                            -FuzzInput $inputResult `
                                                            -Errormessage $Errormessage `
                                                            -OutPath $OutPath `                                    
                                } else {
                                    # Error is not access denied, so we assume our input caused the server to send a error
                                    $Errormessage = $_ -replace '"', ''
                                    $Endpoint =  $Client.Endpoint.ToString()
                                    $Endpoint = $Endpoint.replace("\u", "*u")
                                    Export-ErrorFuzzedInput -MethodName $methodName `
                                                            -RpcServerName $rpcServerName `
                                                            -RpcInterface $Client.InterfaceId.Uuid `
                                                            -Endpoint $Endpoint `
                                                            -ProcedureName $procedureName `
                                                            -MethodDefinition $methodDefinition `
                                                            -Service $service `
                                                            -FuzzInput $inputResult `
                                                            -Errormessage $Errormessage `
                                                            -OutPath $OutPath `
                                }
                            }
                        }
                    } catch {
                        Write-Verbose "[!] Failed to invoke method $($Method.Name) on client $($Client.Endpoint)"
                    }
                }
                try {
                    Disconnect-RpcClient $client
                } catch {
                    Write-Verbose "[!] RPC client already disconnected for $($Client.Endpoint)"
                }
            }
            # Clear the list of stored parameters for the current interface after all stringbindings are fuzzed
            # This ensures that complex parameters are specific to each interface.
            $ComplexList.Clear()
        }
    }
    Write-Host "[+] Completed fuzzing" -ForegroundColor Green
    Write-Host "[+] To load data into Neo4j use: '.\output\Allowed.json' | Import-DatatoNeo4j -Neo4jHost '127.0.0.1:7474' -Neo4jUsername 'neo4j'" -ForegroundColor Green
}